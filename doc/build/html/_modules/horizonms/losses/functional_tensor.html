<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>horizonms.losses.functional_tensor &mdash; HorizonMS 0.1.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/documentation_options.js?v=01f34227"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            HorizonMS
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Python API:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../HorizonMS/horizonms.html">horizonms</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">HorizonMS</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">horizonms.losses.functional_tensor</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for horizonms.losses.functional_tensor</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">from</span> <span class="nn">torch</span> <span class="kn">import</span> <span class="n">Tensor</span>
<span class="kn">from</span> <span class="nn">torch.nn.functional</span> <span class="kn">import</span> <span class="n">grid_sample</span><span class="p">,</span> <span class="n">conv2d</span><span class="p">,</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">pad</span> <span class="k">as</span> <span class="n">torch_pad</span>
<span class="kn">from</span> <span class="nn">torch.jit.annotations</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">BroadcastingList2</span>


<span class="k">def</span> <span class="nf">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;=</span> <span class="mi">2</span>


<span class="k">def</span> <span class="nf">_get_image_size</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Returns (w, h) of tensor image&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]]</span>
    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Unexpected input type&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_get_image_num_channels</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input ndim should be 2 or more. Got </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_max_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
    <span class="c1"># TODO: replace this method with torch.iinfo when it gets torchscript support.</span>
    <span class="c1"># https://github.com/pytorch/pytorch/issues/41492</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">signed</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">is_signed</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">bits</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">max_value</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="o">-</span><span class="n">signed</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">long</span><span class="p">)</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">next_value</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="n">bits</span> <span class="o">-</span> <span class="n">signed</span><span class="p">)</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">next_value</span> <span class="o">&gt;</span> <span class="n">max_value</span><span class="p">:</span>
            <span class="n">max_value</span> <span class="o">=</span> <span class="n">next_value</span>
            <span class="n">bits</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">max_value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">max_value</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>


<div class="viewcode-block" id="convert_image_dtype">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.convert_image_dtype">[docs]</a>
<span class="k">def</span> <span class="nf">convert_image_dtype</span><span class="p">(</span><span class="n">image</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Convert a tensor image to the given ``dtype`` and scale the values accordingly</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        image (torch.Tensor): Image to be converted</span>
<span class="sd">        dtype (torch.dtype): Desired data type of the output</span>

<span class="sd">    Returns:</span>
<span class="sd">        (torch.Tensor): Converted image</span>

<span class="sd">    .. note::</span>

<span class="sd">        When converting from a smaller to a larger integer ``dtype`` the maximum values are **not** mapped exactly.</span>
<span class="sd">        If converted back and forth, this mismatch has no effect.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: When trying to cast :class:`torch.float32` to :class:`torch.int32` or :class:`torch.int64` as</span>
<span class="sd">            well as for trying to cast :class:`torch.float64` to :class:`torch.int64`. These conversions might lead to</span>
<span class="sd">            overflow errors since the floating point ``dtype`` cannot store consecutive integers over the whole range</span>
<span class="sd">            of the integer ``dtype``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">image</span>

    <span class="c1"># TODO: replace with image.dtype.is_floating_point when torchscript supports it</span>
    <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">():</span>

        <span class="c1"># TODO: replace with dtype.is_floating_point when torchscript supports it</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># float to int</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">int64</span><span class="p">))</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">image</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">float64</span> <span class="ow">and</span> <span class="n">dtype</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">int64</span>
        <span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The cast from </span><span class="si">{</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">dtype</span><span class="si">}</span><span class="s2"> cannot be performed safely.&quot;</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="c1"># https://github.com/pytorch/vision/pull/2078#issuecomment-612045321</span>
        <span class="c1"># For data in the range 0-1, (float * 255).to(uint) is only 255</span>
        <span class="c1"># when float is exactly 1.0.</span>
        <span class="c1"># `max + 1 - epsilon` provides more evenly distributed mapping of</span>
        <span class="c1"># ranges of floats to ints.</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="mf">1e-3</span>
        <span class="n">max_val</span> <span class="o">=</span> <span class="n">_max_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">mul</span><span class="p">(</span><span class="n">max_val</span> <span class="o">+</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">eps</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">input_max</span> <span class="o">=</span> <span class="n">_max_value</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">output_max</span> <span class="o">=</span> <span class="n">_max_value</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># int to float</span>
        <span class="c1"># TODO: replace with dtype.is_floating_point when torchscript supports it</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">():</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">image</span> <span class="o">/</span> <span class="n">input_max</span>

        <span class="c1"># int to int</span>
        <span class="k">if</span> <span class="n">input_max</span> <span class="o">&gt;</span> <span class="n">output_max</span><span class="p">:</span>
            <span class="c1"># factor should be forced to int for torch jit script</span>
            <span class="c1"># otherwise factor is a float and image // factor can produce different results</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">input_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">output_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">//</span> <span class="n">factor</span>
            <span class="k">return</span> <span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># factor should be forced to int for torch jit script</span>
            <span class="c1"># otherwise factor is a float and image * factor can produce different results</span>
            <span class="n">factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">output_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="p">(</span><span class="n">input_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">image</span> <span class="o">*</span> <span class="n">factor</span></div>



<div class="viewcode-block" id="vflip">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.vflip">[docs]</a>
<span class="k">def</span> <span class="nf">vflip</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Vertically flip the given the Image Tensor.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image Tensor to be flipped in the form [..., C, H, W].</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor:  Vertically flipped image Tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;tensor is not a torch image.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="hflip">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.hflip">[docs]</a>
<span class="k">def</span> <span class="nf">hflip</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Horizontally flip the given the Image Tensor.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image Tensor to be flipped in the form [..., C, H, W].</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor:  Horizontally flipped image Tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;tensor is not a torch image.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="crop">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.crop">[docs]</a>
<span class="k">def</span> <span class="nf">crop</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">top</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">height</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Crop the given Image Tensor.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be cropped in the form [..., H, W]. (0,0) denotes the top left corner of the image.</span>
<span class="sd">        top (int): Vertical component of the top left corner of the crop box.</span>
<span class="sd">        left (int): Horizontal component of the top left corner of the crop box.</span>
<span class="sd">        height (int): Height of the crop box.</span>
<span class="sd">        width (int): Width of the crop box.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Cropped image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;tensor is not a torch image.&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">top</span><span class="p">:</span><span class="n">top</span> <span class="o">+</span> <span class="n">height</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span><span class="n">left</span> <span class="o">+</span> <span class="n">width</span><span class="p">]</span></div>



<div class="viewcode-block" id="rgb_to_grayscale">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.rgb_to_grayscale">[docs]</a>
<span class="k">def</span> <span class="nf">rgb_to_grayscale</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">num_output_channels</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Convert the given RGB Image Tensor to Grayscale.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    For RGB to Grayscale conversion, ITU-R 601-2 luma transform is performed which</span>
<span class="sd">    is L = R * 0.2989 + G * 0.5870 + B * 0.1140</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be converted to Grayscale in the form [C, H, W].</span>
<span class="sd">        num_output_channels (int): number of channels of the output image. Value can be 1 or 3. Default, 1.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Grayscale version of the image.</span>
<span class="sd">            if num_output_channels = 1 : returned image is single channel</span>

<span class="sd">            if num_output_channels = 3 : returned image is 3 channel with r = g = b</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input image tensor should have at least 3 dimensions, but found </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">c</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input image tensor should 3 channels, but found </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">num_output_channels</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;num_output_channels should be either 1 or 3&#39;</span><span class="p">)</span>

    <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="c1"># This implementation closely follows the TF one:</span>
    <span class="c1"># https://github.com/tensorflow/tensorflow/blob/v2.3.0/tensorflow/python/ops/image_ops_impl.py#L2105-L2138</span>
    <span class="n">l_img</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.2989</span> <span class="o">*</span> <span class="n">r</span> <span class="o">+</span> <span class="mf">0.587</span> <span class="o">*</span> <span class="n">g</span> <span class="o">+</span> <span class="mf">0.114</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">l_img</span> <span class="o">=</span> <span class="n">l_img</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_output_channels</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">l_img</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">l_img</span></div>



<div class="viewcode-block" id="adjust_brightness">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.adjust_brightness">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_brightness</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">brightness_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Adjust brightness of an RGB image.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be adjusted.</span>
<span class="sd">        brightness_factor (float):  How much to adjust the brightness. Can be</span>
<span class="sd">            any non negative number. 0 gives a black image, 1 gives the</span>
<span class="sd">            original image while 2 increases the brightness by a factor of 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Brightness adjusted image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">brightness_factor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;brightness_factor (</span><span class="si">{}</span><span class="s1">) is not non-negative.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">brightness_factor</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;tensor is not a torch image.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_blend</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">brightness_factor</span><span class="p">)</span></div>



<div class="viewcode-block" id="adjust_contrast">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.adjust_contrast">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_contrast</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">contrast_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Adjust contrast of an RGB image.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be adjusted.</span>
<span class="sd">        contrast_factor (float): How much to adjust the contrast. Can be any</span>
<span class="sd">            non negative number. 0 gives a solid gray image, 1 gives the</span>
<span class="sd">            original image while 2 increases the contrast by a factor of 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Contrast adjusted image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">contrast_factor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;contrast_factor (</span><span class="si">{}</span><span class="s1">) is not non-negative.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">contrast_factor</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;tensor is not a torch image.&#39;</span><span class="p">)</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rgb_to_grayscale</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">),</span> <span class="n">dim</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">keepdim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_blend</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">mean</span><span class="p">,</span> <span class="n">contrast_factor</span><span class="p">)</span></div>



<div class="viewcode-block" id="adjust_hue">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.adjust_hue">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_hue</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">hue_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Adjust hue of an image.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    The image hue is adjusted by converting the image to HSV and</span>
<span class="sd">    cyclically shifting the intensities in the hue channel (H).</span>
<span class="sd">    The image is then converted back to original image mode.</span>

<span class="sd">    `hue_factor` is the amount of shift in H channel and must be in the</span>
<span class="sd">    interval `[-0.5, 0.5]`.</span>

<span class="sd">    See `Hue`_ for more details.</span>

<span class="sd">    .. _Hue: https://en.wikipedia.org/wiki/Hue</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be adjusted. Image type is either uint8 or float.</span>
<span class="sd">        hue_factor (float):  How much to shift the hue channel. Should be in</span>
<span class="sd">            [-0.5, 0.5]. 0.5 and -0.5 give complete reversal of hue channel in</span>
<span class="sd">            HSV space in positive and negative direction respectively.</span>
<span class="sd">            0 means no shift. Therefore, both -0.5 and 0.5 will give an image</span>
<span class="sd">            with complementary colors while 0 gives the original image.</span>

<span class="sd">    Returns:</span>
<span class="sd">         Tensor: Hue adjusted image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">&lt;=</span> <span class="n">hue_factor</span> <span class="o">&lt;=</span> <span class="mf">0.5</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;hue_factor (</span><span class="si">{}</span><span class="s1">) is not in [-0.5, 0.5].&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">hue_factor</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input img should be Tensor image&#39;</span><span class="p">)</span>

    <span class="n">orig_dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span> <span class="o">/</span> <span class="mf">255.0</span>

    <span class="n">img</span> <span class="o">=</span> <span class="n">_rgb2hsv</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">+</span> <span class="n">hue_factor</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.0</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">img_hue_adj</span> <span class="o">=</span> <span class="n">_hsv2rgb</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">orig_dtype</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">uint8</span><span class="p">:</span>
        <span class="n">img_hue_adj</span> <span class="o">=</span> <span class="p">(</span><span class="n">img_hue_adj</span> <span class="o">*</span> <span class="mf">255.0</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">orig_dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img_hue_adj</span></div>



<div class="viewcode-block" id="adjust_saturation">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.adjust_saturation">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_saturation</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">saturation_factor</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Adjust color saturation of an RGB image.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be adjusted.</span>
<span class="sd">        saturation_factor (float):  How much to adjust the saturation. Can be any</span>
<span class="sd">            non negative number. 0 gives a black and white image, 1 gives the</span>
<span class="sd">            original image while 2 enhances the saturation by a factor of 2.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Saturation adjusted image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">saturation_factor</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;saturation_factor (</span><span class="si">{}</span><span class="s1">) is not non-negative.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">saturation_factor</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;tensor is not a torch image.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">_blend</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">rgb_to_grayscale</span><span class="p">(</span><span class="n">img</span><span class="p">),</span> <span class="n">saturation_factor</span><span class="p">)</span></div>



<div class="viewcode-block" id="adjust_gamma">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.adjust_gamma">[docs]</a>
<span class="k">def</span> <span class="nf">adjust_gamma</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">gamma</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">gain</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Adjust gamma of an RGB image.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Also known as Power Law Transform. Intensities in RGB mode are adjusted</span>
<span class="sd">    based on the following equation:</span>

<span class="sd">    .. math::</span>
<span class="sd">        `I_{\text{out}} = 255 \times \text{gain} \times \left(\frac{I_{\text{in}}}{255}\right)^{\gamma}`</span>

<span class="sd">    See `Gamma Correction`_ for more details.</span>

<span class="sd">    .. _Gamma Correction: https://en.wikipedia.org/wiki/Gamma_correction</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Tensor of RBG values to be adjusted.</span>
<span class="sd">        gamma (float): Non negative real number, same as :math:`\gamma` in the equation.</span>
<span class="sd">            gamma larger than 1 make the shadows darker,</span>
<span class="sd">            while gamma smaller than 1 make dark regions lighter.</span>
<span class="sd">        gain (float): The constant multiplier.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input img should be a Tensor.&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gamma</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Gamma should be a non-negative real number&#39;</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">img</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">convert_image_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">gain</span> <span class="o">*</span> <span class="n">result</span> <span class="o">**</span> <span class="n">gamma</span><span class="p">)</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">convert_image_dtype</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>



<div class="viewcode-block" id="center_crop">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.center_crop">[docs]</a>
<span class="k">def</span> <span class="nf">center_crop</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">output_size</span><span class="p">:</span> <span class="n">BroadcastingList2</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;DEPRECATED. Crop the Image Tensor and resize it to desired size.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This method is deprecated and will be removed in future releases.</span>
<span class="sd">        Please, use ``F.center_crop`` instead.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be cropped.</span>
<span class="sd">        output_size (sequence or int): (height, width) of the crop box. If int,</span>
<span class="sd">                it is used for both directions</span>

<span class="sd">    Returns:</span>
<span class="sd">            Tensor: Cropped image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;This method is deprecated and will be removed in future releases. &quot;</span>
        <span class="s2">&quot;Please, use ``F.center_crop`` instead.&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;tensor is not a torch image.&#39;</span><span class="p">)</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">image_width</span><span class="p">,</span> <span class="n">image_height</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">crop_height</span><span class="p">,</span> <span class="n">crop_width</span> <span class="o">=</span> <span class="n">output_size</span>
    <span class="c1"># crop_top = int(round((image_height - crop_height) / 2.))</span>
    <span class="c1"># Result can be different between python func and scripted func</span>
    <span class="c1"># Temporary workaround:</span>
    <span class="n">crop_top</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">image_height</span> <span class="o">-</span> <span class="n">crop_height</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="c1"># crop_left = int(round((image_width - crop_width) / 2.))</span>
    <span class="c1"># Result can be different between python func and scripted func</span>
    <span class="c1"># Temporary workaround:</span>
    <span class="n">crop_left</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">image_width</span> <span class="o">-</span> <span class="n">crop_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">crop_top</span><span class="p">,</span> <span class="n">crop_left</span><span class="p">,</span> <span class="n">crop_height</span><span class="p">,</span> <span class="n">crop_width</span><span class="p">)</span></div>



<div class="viewcode-block" id="five_crop">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.five_crop">[docs]</a>
<span class="k">def</span> <span class="nf">five_crop</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">BroadcastingList2</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;DEPRECATED. Crop the given Image Tensor into four corners and the central crop.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This method is deprecated and will be removed in future releases.</span>
<span class="sd">        Please, use ``F.five_crop`` instead.</span>

<span class="sd">    .. Note::</span>

<span class="sd">        This transform returns a List of Tensors and there may be a</span>
<span class="sd">        mismatch in the number of inputs and targets your ``Dataset`` returns.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be cropped.</span>
<span class="sd">        size (sequence or int): Desired output size of the crop. If size is an</span>
<span class="sd">            int instead of sequence like (h, w), a square crop (size, size) is</span>
<span class="sd">            made.</span>

<span class="sd">    Returns:</span>
<span class="sd">       List: List (tl, tr, bl, br, center)</span>
<span class="sd">                Corresponding top left, top right, bottom left, bottom right and center crop.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;This method is deprecated and will be removed in future releases. &quot;</span>
        <span class="s2">&quot;Please, use ``F.five_crop`` instead.&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;tensor is not a torch image.&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Please provide only two dimensions (h, w) for size.&quot;</span>

    <span class="n">_</span><span class="p">,</span> <span class="n">image_width</span><span class="p">,</span> <span class="n">image_height</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
    <span class="n">crop_height</span><span class="p">,</span> <span class="n">crop_width</span> <span class="o">=</span> <span class="n">size</span>
    <span class="k">if</span> <span class="n">crop_width</span> <span class="o">&gt;</span> <span class="n">image_width</span> <span class="ow">or</span> <span class="n">crop_height</span> <span class="o">&gt;</span> <span class="n">image_height</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Requested crop size </span><span class="si">{}</span><span class="s2"> is bigger than input size </span><span class="si">{}</span><span class="s2">&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="n">image_height</span><span class="p">,</span> <span class="n">image_width</span><span class="p">)))</span>

    <span class="n">tl</span> <span class="o">=</span> <span class="n">crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">crop_width</span><span class="p">,</span> <span class="n">crop_height</span><span class="p">)</span>
    <span class="n">tr</span> <span class="o">=</span> <span class="n">crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">image_width</span> <span class="o">-</span> <span class="n">crop_width</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_width</span><span class="p">,</span> <span class="n">crop_height</span><span class="p">)</span>
    <span class="n">bl</span> <span class="o">=</span> <span class="n">crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">image_height</span> <span class="o">-</span> <span class="n">crop_height</span><span class="p">,</span> <span class="n">crop_width</span><span class="p">,</span> <span class="n">image_height</span><span class="p">)</span>
    <span class="n">br</span> <span class="o">=</span> <span class="n">crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">image_width</span> <span class="o">-</span> <span class="n">crop_width</span><span class="p">,</span> <span class="n">image_height</span> <span class="o">-</span> <span class="n">crop_height</span><span class="p">,</span> <span class="n">image_width</span><span class="p">,</span> <span class="n">image_height</span><span class="p">)</span>
    <span class="n">center</span> <span class="o">=</span> <span class="n">center_crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="n">crop_height</span><span class="p">,</span> <span class="n">crop_width</span><span class="p">))</span>

    <span class="k">return</span> <span class="p">[</span><span class="n">tl</span><span class="p">,</span> <span class="n">tr</span><span class="p">,</span> <span class="n">bl</span><span class="p">,</span> <span class="n">br</span><span class="p">,</span> <span class="n">center</span><span class="p">]</span></div>



<div class="viewcode-block" id="ten_crop">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.ten_crop">[docs]</a>
<span class="k">def</span> <span class="nf">ten_crop</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">BroadcastingList2</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">vertical_flip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tensor</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;DEPRECATED. Crop the given Image Tensor into four corners and the central crop plus the</span>
<span class="sd">        flipped version of these (horizontal flipping is used by default).</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        This method is deprecated and will be removed in future releases.</span>
<span class="sd">        Please, use ``F.ten_crop`` instead.</span>

<span class="sd">    .. Note::</span>

<span class="sd">        This transform returns a List of images and there may be a</span>
<span class="sd">        mismatch in the number of inputs and targets your ``Dataset`` returns.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be cropped.</span>
<span class="sd">        size (sequence or int): Desired output size of the crop. If size is an</span>
<span class="sd">            int instead of sequence like (h, w), a square crop (size, size) is</span>
<span class="sd">            made.</span>
<span class="sd">        vertical_flip (bool): Use vertical flipping instead of horizontal</span>

<span class="sd">    Returns:</span>
<span class="sd">       List: List (tl, tr, bl, br, center, tl_flip, tr_flip, bl_flip, br_flip, center_flip)</span>
<span class="sd">                Corresponding top left, top right, bottom left, bottom right and center crop</span>
<span class="sd">                and same for the flipped image&#39;s tensor.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;This method is deprecated and will be removed in future releases. &quot;</span>
        <span class="s2">&quot;Please, use ``F.ten_crop`` instead.&quot;</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;tensor is not a torch image.&#39;</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;Please provide only two dimensions (h, w) for size.&quot;</span>
    <span class="n">first_five</span> <span class="o">=</span> <span class="n">five_crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">vertical_flip</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">vflip</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">hflip</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="n">second_five</span> <span class="o">=</span> <span class="n">five_crop</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">first_five</span> <span class="o">+</span> <span class="n">second_five</span></div>



<span class="k">def</span> <span class="nf">_blend</span><span class="p">(</span><span class="n">img1</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">img2</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">ratio</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
    <span class="n">bound</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">img1</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">()</span> <span class="k">else</span> <span class="mf">255.0</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">ratio</span> <span class="o">*</span> <span class="n">img1</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">ratio</span><span class="p">)</span> <span class="o">*</span> <span class="n">img2</span><span class="p">)</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">bound</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">img1</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_rgb2hsv</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
    <span class="n">r</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Implementation is based on https://github.com/python-pillow/Pillow/blob/4174d4267616897df3746d315d5a2d0f82c656ee/</span>
    <span class="c1"># src/libImaging/Convert.c#L330</span>
    <span class="n">maxc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>
    <span class="n">minc</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">values</span>

    <span class="c1"># The algorithm erases S and H channel where `maxc = minc`. This avoids NaN</span>
    <span class="c1"># from happening in the results, because</span>
    <span class="c1">#   + S channel has division by `maxc`, which is zero only if `maxc = minc`</span>
    <span class="c1">#   + H channel has division by `(maxc - minc)`.</span>
    <span class="c1">#</span>
    <span class="c1"># Instead of overwriting NaN afterwards, we just prevent it from occuring so</span>
    <span class="c1"># we don&#39;t need to deal with it in case we save the NaN in a buffer in</span>
    <span class="c1"># backprop, if it is ever supported, but it doesn&#39;t hurt to do so.</span>
    <span class="n">eqc</span> <span class="o">=</span> <span class="n">maxc</span> <span class="o">==</span> <span class="n">minc</span>

    <span class="n">cr</span> <span class="o">=</span> <span class="n">maxc</span> <span class="o">-</span> <span class="n">minc</span>
    <span class="c1"># Since `eqc =&gt; cr = 0`, replacing denominator with 1 when `eqc` is fine.</span>
    <span class="n">ones</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">maxc</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">cr</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">eqc</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span> <span class="n">maxc</span><span class="p">)</span>
    <span class="c1"># Note that `eqc =&gt; maxc = minc = r = g = b`. So the following calculation</span>
    <span class="c1"># of `h` would reduce to `bc - gc + 2 + rc - bc + 4 + rc - bc = 6` so it</span>
    <span class="c1"># would not matter what values `rc`, `gc`, and `bc` have here, and thus</span>
    <span class="c1"># replacing denominator with 1 when `eqc` is fine.</span>
    <span class="n">cr_divisor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">eqc</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span> <span class="n">cr</span><span class="p">)</span>
    <span class="n">rc</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxc</span> <span class="o">-</span> <span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">cr_divisor</span>
    <span class="n">gc</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxc</span> <span class="o">-</span> <span class="n">g</span><span class="p">)</span> <span class="o">/</span> <span class="n">cr_divisor</span>
    <span class="n">bc</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxc</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span> <span class="o">/</span> <span class="n">cr_divisor</span>

    <span class="n">hr</span> <span class="o">=</span> <span class="p">(</span><span class="n">maxc</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">bc</span> <span class="o">-</span> <span class="n">gc</span><span class="p">)</span>
    <span class="n">hg</span> <span class="o">=</span> <span class="p">((</span><span class="n">maxc</span> <span class="o">==</span> <span class="n">g</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">maxc</span> <span class="o">!=</span> <span class="n">r</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mf">2.0</span> <span class="o">+</span> <span class="n">rc</span> <span class="o">-</span> <span class="n">bc</span><span class="p">)</span>
    <span class="n">hb</span> <span class="o">=</span> <span class="p">((</span><span class="n">maxc</span> <span class="o">!=</span> <span class="n">g</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">maxc</span> <span class="o">!=</span> <span class="n">r</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="mf">4.0</span> <span class="o">+</span> <span class="n">gc</span> <span class="o">-</span> <span class="n">rc</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">hr</span> <span class="o">+</span> <span class="n">hg</span> <span class="o">+</span> <span class="n">hb</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">fmod</span><span class="p">((</span><span class="n">h</span> <span class="o">/</span> <span class="mf">6.0</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">),</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">maxc</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_hsv2rgb</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">unbind</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="mf">6.0</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">h</span> <span class="o">*</span> <span class="mf">6.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">((</span><span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">s</span><span class="p">)),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">((</span><span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="n">f</span><span class="p">)),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">clamp</span><span class="p">((</span><span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">s</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">f</span><span class="p">))),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">6</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">i</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">a1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">a3</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">q</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">a4</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">((</span><span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">a3</span><span class="p">),</span> <span class="n">dim</span><span class="o">=-</span><span class="mi">4</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">torch</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s2">&quot;...ijk, ...xijk -&gt; ...xjk&quot;</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">a4</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_pad_symmetric</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">padding</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
    <span class="c1"># padding is left, right, top, bottom</span>

    <span class="c1"># crop if needed</span>
    <span class="k">if</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">crop_left</span><span class="p">,</span> <span class="n">crop_right</span><span class="p">,</span> <span class="n">crop_top</span><span class="p">,</span> <span class="n">crop_bottom</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">padding</span><span class="p">]</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">crop_top</span><span class="p">:</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">crop_bottom</span><span class="p">,</span> <span class="n">crop_left</span><span class="p">:</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">crop_right</span><span class="p">]</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="p">[</span><span class="nb">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">padding</span><span class="p">]</span>

    <span class="n">in_sizes</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>

    <span class="n">x_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>  <span class="c1"># [0, 1, 2, 3, ...]</span>
    <span class="n">left_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># e.g. [3, 2, 1, 0]</span>
    <span class="n">right_indices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>  <span class="c1"># e.g. [-1, -2, -3]</span>
    <span class="n">x_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">left_indices</span> <span class="o">+</span> <span class="n">x_indices</span> <span class="o">+</span> <span class="n">right_indices</span><span class="p">)</span>

    <span class="n">y_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">in_sizes</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])]</span>
    <span class="n">top_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">bottom_indices</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">])]</span>
    <span class="n">y_indices</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">top_indices</span> <span class="o">+</span> <span class="n">y_indices</span> <span class="o">+</span> <span class="n">bottom_indices</span><span class="p">)</span>

    <span class="n">ndim</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span><span class="p">[:,</span> <span class="n">y_indices</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">x_indices</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]]</span>
    <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">img</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">y_indices</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">x_indices</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Symmetric padding of N-D tensors are not supported yet&quot;</span><span class="p">)</span>


<div class="viewcode-block" id="pad">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.pad">[docs]</a>
<span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">padding</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">fill</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">padding_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;constant&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Pad the given Tensor Image on all sides with specified padding mode and fill value.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be padded.</span>
<span class="sd">        padding (int or tuple or list): Padding on each border. If a single int is provided this</span>
<span class="sd">            is used to pad all borders. If a tuple or list of length 2 is provided this is the padding</span>
<span class="sd">            on left/right and top/bottom respectively. If a tuple or list of length 4 is provided</span>
<span class="sd">            this is the padding for the left, top, right and bottom borders</span>
<span class="sd">            respectively. In torchscript mode padding as single int is not supported, use a tuple or</span>
<span class="sd">            list of length 1: ``[padding, ]``.</span>
<span class="sd">        fill (int): Pixel fill value for constant fill. Default is 0.</span>
<span class="sd">            This value is only used when the padding_mode is constant</span>
<span class="sd">        padding_mode (str): Type of padding. Should be: constant, edge or reflect. Default is constant.</span>
<span class="sd">            Mode symmetric is not yet supported for Tensor inputs.</span>

<span class="sd">            - constant: pads with a constant value, this value is specified with fill</span>

<span class="sd">            - edge: pads with the last value on the edge of the image</span>

<span class="sd">            - reflect: pads with reflection of image (without repeating the last value on the edge)</span>

<span class="sd">                       padding [1, 2, 3, 4] with 2 elements on both sides in reflect mode</span>
<span class="sd">                       will result in [3, 2, 1, 2, 3, 4, 3, 2]</span>

<span class="sd">            - symmetric: pads with reflection of image (repeating the last value on the edge)</span>

<span class="sd">                         padding [1, 2, 3, 4] with 2 elements on both sides in symmetric mode</span>
<span class="sd">                         will result in [2, 1, 1, 2, 3, 4, 4, 3]</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Padded image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;tensor is not a torch image.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got inappropriate padding arg&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got inappropriate fill arg&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding_mode</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got inappropriate padding_mode arg&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Padding must be an int or a 1, 2, or 4 element tuple, not a &quot;</span> <span class="o">+</span>
                         <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> element tuple&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">padding</span><span class="p">)))</span>

    <span class="k">if</span> <span class="n">padding_mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="s2">&quot;edge&quot;</span><span class="p">,</span> <span class="s2">&quot;reflect&quot;</span><span class="p">,</span> <span class="s2">&quot;symmetric&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Padding mode should be either constant, edge, reflect or symmetric&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">padding</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">jit</span><span class="o">.</span><span class="n">is_scripting</span><span class="p">():</span>
            <span class="c1"># This maybe unreachable</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;padding can&#39;t be an int while torchscripting, set it as a list [value, ]&quot;</span><span class="p">)</span>
        <span class="n">pad_left</span> <span class="o">=</span> <span class="n">pad_right</span> <span class="o">=</span> <span class="n">pad_top</span> <span class="o">=</span> <span class="n">pad_bottom</span> <span class="o">=</span> <span class="n">padding</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">pad_left</span> <span class="o">=</span> <span class="n">pad_right</span> <span class="o">=</span> <span class="n">pad_top</span> <span class="o">=</span> <span class="n">pad_bottom</span> <span class="o">=</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">padding</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">pad_left</span> <span class="o">=</span> <span class="n">pad_right</span> <span class="o">=</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pad_top</span> <span class="o">=</span> <span class="n">pad_bottom</span> <span class="o">=</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pad_left</span> <span class="o">=</span> <span class="n">padding</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pad_top</span> <span class="o">=</span> <span class="n">padding</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">pad_right</span> <span class="o">=</span> <span class="n">padding</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">pad_bottom</span> <span class="o">=</span> <span class="n">padding</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>

    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">pad_left</span><span class="p">,</span> <span class="n">pad_right</span><span class="p">,</span> <span class="n">pad_top</span><span class="p">,</span> <span class="n">pad_bottom</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">padding_mode</span> <span class="o">==</span> <span class="s2">&quot;edge&quot;</span><span class="p">:</span>
        <span class="c1"># remap padding_mode str</span>
        <span class="n">padding_mode</span> <span class="o">=</span> <span class="s2">&quot;replicate&quot;</span>
    <span class="k">elif</span> <span class="n">padding_mode</span> <span class="o">==</span> <span class="s2">&quot;symmetric&quot;</span><span class="p">:</span>
        <span class="c1"># route to another implementation</span>
        <span class="k">return</span> <span class="n">_pad_symmetric</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>

    <span class="n">need_squeeze</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">need_squeeze</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">need_cast</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">padding_mode</span> <span class="o">!=</span> <span class="s2">&quot;constant&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="c1"># Here we temporary cast input tensor to float</span>
        <span class="c1"># until pytorch issue is resolved :</span>
        <span class="c1"># https://github.com/pytorch/pytorch/issues/40763</span>
        <span class="n">need_cast</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="n">img</span> <span class="o">=</span> <span class="n">torch_pad</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">padding_mode</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">fill</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">need_squeeze</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">need_cast</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img</span></div>



<div class="viewcode-block" id="resize">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.resize">[docs]</a>
<span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">interpolation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Resize the input Tensor to the given size.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be resized.</span>
<span class="sd">        size (int or tuple or list): Desired output size. If size is a sequence like</span>
<span class="sd">            (h, w), the output size will be matched to this. If size is an int,</span>
<span class="sd">            the smaller edge of the image will be matched to this number maintaining</span>
<span class="sd">            the aspect ratio. i.e, if height &gt; width, then image will be rescaled to</span>
<span class="sd">            :math:`\left(\text{size} \times \frac{\text{height}}{\text{width}}, \text{size}\right)`.</span>
<span class="sd">            In torchscript mode padding as a single int is not supported, use a tuple or</span>
<span class="sd">            list of length 1: ``[size, ]``.</span>
<span class="sd">        interpolation (int, optional): Desired interpolation. Default is bilinear (=2). Other supported values:</span>
<span class="sd">            nearest(=0) and bicubic(=3).</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Resized image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;tensor is not a torch image.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got inappropriate size arg&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">interpolation</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Got inappropriate interpolation arg&quot;</span><span class="p">)</span>

    <span class="n">_interpolation_modes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">,</span>
        <span class="mi">3</span><span class="p">:</span> <span class="s2">&quot;bicubic&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">interpolation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_interpolation_modes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;This interpolation mode is unsupported with Tensor input&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">size</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Size must be an int or a 1 or 2 element tuple/list, not a &quot;</span>
                         <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> element tuple/list&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)))</span>

    <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">_get_image_size</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">size_w</span><span class="p">,</span> <span class="n">size_h</span> <span class="o">=</span> <span class="n">size</span><span class="p">,</span> <span class="n">size</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">size_w</span><span class="p">,</span> <span class="n">size_h</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">size_w</span><span class="p">,</span> <span class="n">size_h</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Convention (h, w)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">w</span> <span class="o">&lt;</span> <span class="n">h</span><span class="p">:</span>
            <span class="n">size_h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size_w</span> <span class="o">*</span> <span class="n">h</span> <span class="o">/</span> <span class="n">w</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size_w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">size_h</span> <span class="o">*</span> <span class="n">w</span> <span class="o">/</span> <span class="n">h</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">w</span> <span class="o">&lt;=</span> <span class="n">h</span> <span class="ow">and</span> <span class="n">w</span> <span class="o">==</span> <span class="n">size_w</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">h</span> <span class="o">&lt;=</span> <span class="n">w</span> <span class="ow">and</span> <span class="n">h</span> <span class="o">==</span> <span class="n">size_h</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">img</span>

    <span class="c1"># make image NCHW</span>
    <span class="n">need_squeeze</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">need_squeeze</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">mode</span> <span class="o">=</span> <span class="n">_interpolation_modes</span><span class="p">[</span><span class="n">interpolation</span><span class="p">]</span>

    <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">need_cast</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
        <span class="n">need_cast</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># Define align_corners to avoid warnings</span>
    <span class="n">align_corners</span> <span class="o">=</span> <span class="kc">False</span> <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;bilinear&quot;</span><span class="p">,</span> <span class="s2">&quot;bicubic&quot;</span><span class="p">]</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="n">img</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">[</span><span class="n">size_h</span><span class="p">,</span> <span class="n">size_w</span><span class="p">],</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">align_corners</span><span class="o">=</span><span class="n">align_corners</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">need_squeeze</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">need_cast</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;bicubic&quot;</span><span class="p">:</span>
            <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">clamp</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mi">255</span><span class="p">)</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img</span></div>



<span class="k">def</span> <span class="nf">_assert_grid_transform_inputs</span><span class="p">(</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span>
        <span class="n">matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
        <span class="n">resample</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">fillcolor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">_interpolation_modes</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span>
        <span class="n">coeffs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">):</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Input img should be Tensor Image&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Argument matrix should be a list&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">6</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument matrix should have 6 float values&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">coeffs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">coeffs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Argument coeffs should have 8 float values&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">fillcolor</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Argument fill/fillcolor is not supported for Tensor input. Fill value is zero&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">resample</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">_interpolation_modes</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Resampling mode &#39;</span><span class="si">{}</span><span class="s2">&#39; is unsupported with Tensor input&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">resample</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_cast_squeeze_in</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">req_dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Tensor</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">]:</span>
    <span class="n">need_squeeze</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># make image NCHW</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">need_squeeze</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span>
    <span class="n">need_cast</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">out_dtype</span> <span class="o">!=</span> <span class="n">req_dtype</span><span class="p">:</span>
        <span class="n">need_cast</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">req_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img</span><span class="p">,</span> <span class="n">need_cast</span><span class="p">,</span> <span class="n">need_squeeze</span><span class="p">,</span> <span class="n">out_dtype</span>


<span class="k">def</span> <span class="nf">_cast_squeeze_out</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">need_cast</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">need_squeeze</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">out_dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">need_squeeze</span><span class="p">:</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">need_cast</span><span class="p">:</span>
        <span class="c1"># it is better to round before cast</span>
        <span class="n">img</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">out_dtype</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">img</span>


<span class="k">def</span> <span class="nf">_apply_grid_transform</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>

    <span class="n">img</span><span class="p">,</span> <span class="n">need_cast</span><span class="p">,</span> <span class="n">need_squeeze</span><span class="p">,</span> <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">_cast_squeeze_in</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Apply same grid to a batch of images</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">grid_sample</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">padding_mode</span><span class="o">=</span><span class="s2">&quot;zeros&quot;</span><span class="p">,</span> <span class="n">align_corners</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">img</span> <span class="o">=</span> <span class="n">_cast_squeeze_out</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">need_cast</span><span class="p">,</span> <span class="n">need_squeeze</span><span class="p">,</span> <span class="n">out_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img</span>


<span class="k">def</span> <span class="nf">_gen_affine_grid</span><span class="p">(</span>
        <span class="n">theta</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">w</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">ow</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">oh</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
    <span class="c1"># https://github.com/pytorch/pytorch/blob/74b65c32be68b15dc7c9e8bb62459efbfbde33d8/aten/src/ATen/native/</span>
    <span class="c1"># AffineGridGenerator.cpp#L18</span>
    <span class="c1"># Difference with AffineGridGenerator is that:</span>
    <span class="c1"># 1) we normalize grid values after applying theta</span>
    <span class="c1"># 2) we can normalize by other image size, such that it covers &quot;extend&quot; option like in PIL.Image.rotate</span>

    <span class="n">d</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">base_grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">oh</span><span class="p">,</span> <span class="n">ow</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">theta</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">theta</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">base_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">ow</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">ow</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">ow</span><span class="p">))</span>
    <span class="n">base_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">oh</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">d</span><span class="p">,</span> <span class="n">oh</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">oh</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze_</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">base_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">rescaled_theta</span> <span class="o">=</span> <span class="n">theta</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">theta</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">theta</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">output_grid</span> <span class="o">=</span> <span class="n">base_grid</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">oh</span> <span class="o">*</span> <span class="n">ow</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">rescaled_theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output_grid</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">oh</span><span class="p">,</span> <span class="n">ow</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<div class="viewcode-block" id="affine">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.affine">[docs]</a>
<span class="k">def</span> <span class="nf">affine</span><span class="p">(</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">resample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fillcolor</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Apply affine transformation on the Tensor image keeping image center invariant.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): image to be rotated.</span>
<span class="sd">        matrix (list of floats): list of 6 float values representing inverse matrix for affine transformation.</span>
<span class="sd">        resample (int, optional): An optional resampling filter. Default is nearest (=0). Other supported values:</span>
<span class="sd">            bilinear(=2).</span>
<span class="sd">        fillcolor (int, optional): this option is not supported for Tensor input. Fill value for the area outside the</span>
<span class="sd">            transform in the output image is always 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Transformed image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_interpolation_modes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">_assert_grid_transform_inputs</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">resample</span><span class="p">,</span> <span class="n">fillcolor</span><span class="p">,</span> <span class="n">_interpolation_modes</span><span class="p">)</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># grid will be generated on the same device as theta and img</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">_gen_affine_grid</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">h</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">ow</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">oh</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">_interpolation_modes</span><span class="p">[</span><span class="n">resample</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">_apply_grid_transform</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_compute_output_size</span><span class="p">(</span><span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">w</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">h</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>

    <span class="c1"># Inspired of PIL implementation:</span>
    <span class="c1"># https://github.com/python-pillow/Pillow/blob/11de3318867e4398057373ee9f12dcb33db7335c/src/PIL/Image.py#L2054</span>

    <span class="c1"># pts are Top-Left, Top-Right, Bottom-Left, Bottom-Right points.</span>
    <span class="n">pts</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span>
        <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">[</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">h</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span>
    <span class="p">])</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">new_pts</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">theta</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">min_vals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">new_pts</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">max_vals</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">new_pts</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Truncate precision to 1e-4 to avoid ceil of Xe-15 to 1.0</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="mf">1e-4</span>
    <span class="n">cmax</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">max_vals</span> <span class="o">/</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_</span><span class="p">()</span> <span class="o">*</span> <span class="n">tol</span><span class="p">)</span>
    <span class="n">cmin</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="n">min_vals</span> <span class="o">/</span> <span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">trunc_</span><span class="p">()</span> <span class="o">*</span> <span class="n">tol</span><span class="p">)</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">cmax</span> <span class="o">-</span> <span class="n">cmin</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


<div class="viewcode-block" id="rotate">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.rotate">[docs]</a>
<span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">matrix</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">resample</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">expand</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">fill</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Rotate the Tensor image by angle.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): image to be rotated.</span>
<span class="sd">        matrix (list of floats): list of 6 float values representing inverse matrix for rotation transformation.</span>
<span class="sd">            Translation part (``matrix[2]`` and ``matrix[5]``) should be in pixel coordinates.</span>
<span class="sd">        resample (int, optional): An optional resampling filter. Default is nearest (=0). Other supported values:</span>
<span class="sd">            bilinear(=2).</span>
<span class="sd">        expand (bool, optional): Optional expansion flag.</span>
<span class="sd">            If true, expands the output image to make it large enough to hold the entire rotated image.</span>
<span class="sd">            If false or omitted, make the output image the same size as the input image.</span>
<span class="sd">            Note that the expand flag assumes rotation around the center and no translation.</span>
<span class="sd">        fill (n-tuple or int or float): this option is not supported for Tensor input.</span>
<span class="sd">            Fill value for the area outside the transform in the output image is always 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: Rotated image.</span>

<span class="sd">    .. _filters: https://pillow.readthedocs.io/en/latest/handbook/concepts.html#filters</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_interpolation_modes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">_assert_grid_transform_inputs</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">matrix</span><span class="p">,</span> <span class="n">resample</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="n">_interpolation_modes</span><span class="p">)</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">ow</span><span class="p">,</span> <span class="n">oh</span> <span class="o">=</span> <span class="n">_compute_output_size</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span> <span class="k">if</span> <span class="n">expand</span> <span class="k">else</span> <span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span>
    <span class="n">theta</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">device</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
    <span class="c1"># grid will be generated on the same device as theta and img</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">_gen_affine_grid</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="n">h</span><span class="p">,</span> <span class="n">ow</span><span class="o">=</span><span class="n">ow</span><span class="p">,</span> <span class="n">oh</span><span class="o">=</span><span class="n">oh</span><span class="p">)</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">_interpolation_modes</span><span class="p">[</span><span class="n">resample</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">_apply_grid_transform</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_perspective_grid</span><span class="p">(</span><span class="n">coeffs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">ow</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">oh</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span><span class="p">):</span>
    <span class="c1"># https://github.com/python-pillow/Pillow/blob/4634eafe3c695a014267eefdce830b4a825beed7/</span>
    <span class="c1"># src/libImaging/Geometry.c#L394</span>

    <span class="c1">#</span>
    <span class="c1"># x_out = (coeffs[0] * x + coeffs[1] * y + coeffs[2]) / (coeffs[6] * x + coeffs[7] * y + 1)</span>
    <span class="c1"># y_out = (coeffs[3] * x + coeffs[4] * y + coeffs[5]) / (coeffs[6] * x + coeffs[7] * y + 1)</span>
    <span class="c1">#</span>
    <span class="n">theta1</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span>
        <span class="p">[</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span>
        <span class="p">[</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">5</span><span class="p">]]</span>
    <span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">theta2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([[</span>
        <span class="p">[</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">],</span>
        <span class="p">[</span><span class="n">coeffs</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">coeffs</span><span class="p">[</span><span class="mi">7</span><span class="p">],</span> <span class="mf">1.0</span><span class="p">]</span>
    <span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>

    <span class="n">d</span> <span class="o">=</span> <span class="mf">0.5</span>
    <span class="n">base_grid</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">oh</span><span class="p">,</span> <span class="n">ow</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">base_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ow</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">ow</span><span class="p">))</span>
    <span class="n">base_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">copy_</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">oh</span> <span class="o">*</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">d</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">oh</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze_</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">base_grid</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">fill_</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">rescaled_theta1</span> <span class="o">=</span> <span class="n">theta1</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">ow</span><span class="p">,</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">oh</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">device</span><span class="p">)</span>
    <span class="n">output_grid1</span> <span class="o">=</span> <span class="n">base_grid</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">oh</span> <span class="o">*</span> <span class="n">ow</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">rescaled_theta1</span><span class="p">)</span>
    <span class="n">output_grid2</span> <span class="o">=</span> <span class="n">base_grid</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">oh</span> <span class="o">*</span> <span class="n">ow</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">bmm</span><span class="p">(</span><span class="n">theta2</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">output_grid</span> <span class="o">=</span> <span class="n">output_grid1</span> <span class="o">/</span> <span class="n">output_grid2</span> <span class="o">-</span> <span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">output_grid</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">oh</span><span class="p">,</span> <span class="n">ow</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>


<div class="viewcode-block" id="perspective">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.perspective">[docs]</a>
<span class="k">def</span> <span class="nf">perspective</span><span class="p">(</span>
        <span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">perspective_coeffs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">interpolation</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">fill</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Perform perspective transform of the given Tensor image.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be transformed.</span>
<span class="sd">        perspective_coeffs (list of float): perspective transformation coefficients.</span>
<span class="sd">        interpolation (int): Interpolation type. Default, ``PIL.Image.BILINEAR``.</span>
<span class="sd">        fill (n-tuple or int or float): this option is not supported for Tensor input. Fill value for the area</span>
<span class="sd">            outside the transform in the output image is always 0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: transformed image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">and</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Input img should be Tensor Image&#39;</span><span class="p">)</span>

    <span class="n">_interpolation_modes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
        <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;bilinear&quot;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">_assert_grid_transform_inputs</span><span class="p">(</span>
        <span class="n">img</span><span class="p">,</span>
        <span class="n">matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">resample</span><span class="o">=</span><span class="n">interpolation</span><span class="p">,</span>
        <span class="n">fillcolor</span><span class="o">=</span><span class="n">fill</span><span class="p">,</span>
        <span class="n">_interpolation_modes</span><span class="o">=</span><span class="n">_interpolation_modes</span><span class="p">,</span>
        <span class="n">coeffs</span><span class="o">=</span><span class="n">perspective_coeffs</span>
    <span class="p">)</span>

    <span class="n">ow</span><span class="p">,</span> <span class="n">oh</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span>
    <span class="n">grid</span> <span class="o">=</span> <span class="n">_perspective_grid</span><span class="p">(</span><span class="n">perspective_coeffs</span><span class="p">,</span> <span class="n">ow</span><span class="o">=</span><span class="n">ow</span><span class="p">,</span> <span class="n">oh</span><span class="o">=</span><span class="n">oh</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">mode</span> <span class="o">=</span> <span class="n">_interpolation_modes</span><span class="p">[</span><span class="n">interpolation</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">_apply_grid_transform</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_get_gaussian_kernel1d</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sigma</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
    <span class="n">ksize_half</span> <span class="o">=</span> <span class="p">(</span><span class="n">kernel_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="n">ksize_half</span><span class="p">,</span> <span class="n">ksize_half</span><span class="p">,</span> <span class="n">steps</span><span class="o">=</span><span class="n">kernel_size</span><span class="p">)</span>
    <span class="n">pdf</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">sigma</span><span class="p">)</span><span class="o">.</span><span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
    <span class="n">kernel1d</span> <span class="o">=</span> <span class="n">pdf</span> <span class="o">/</span> <span class="n">pdf</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">kernel1d</span>


<span class="k">def</span> <span class="nf">_get_gaussian_kernel2d</span><span class="p">(</span>
        <span class="n">kernel_size</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">dtype</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">device</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
    <span class="n">kernel1d_x</span> <span class="o">=</span> <span class="n">_get_gaussian_kernel1d</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">kernel1d_y</span> <span class="o">=</span> <span class="n">_get_gaussian_kernel1d</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sigma</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">to</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">kernel2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mm</span><span class="p">(</span><span class="n">kernel1d_y</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">],</span> <span class="n">kernel1d_x</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
    <span class="k">return</span> <span class="n">kernel2d</span>


<div class="viewcode-block" id="gaussian_blur">
<a class="viewcode-back" href="../../../HorizonMS/horizonms.losses.html#horizonms.losses.functional_tensor.gaussian_blur">[docs]</a>
<span class="k">def</span> <span class="nf">gaussian_blur</span><span class="p">(</span><span class="n">img</span><span class="p">:</span> <span class="n">Tensor</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">sigma</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Tensor</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;PRIVATE METHOD. Performs Gaussian blurring on the img by given kernel.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        Module ``transforms.functional_tensor`` is private and should not be used in user application.</span>
<span class="sd">        Please, consider instead using methods from `transforms.functional` module.</span>

<span class="sd">    Args:</span>
<span class="sd">        img (Tensor): Image to be blurred</span>
<span class="sd">        kernel_size (sequence of int or int): Kernel size of the Gaussian kernel ``(kx, ky)``.</span>
<span class="sd">        sigma (sequence of float or float, optional): Standard deviation of the Gaussian kernel ``(sx, sy)``.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tensor: An image that is blurred using gaussian kernel of given parameters</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">torch</span><span class="o">.</span><span class="n">Tensor</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_is_tensor_a_torch_image</span><span class="p">(</span><span class="n">img</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;img should be Tensor Image. Got </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span>

    <span class="n">dtype</span> <span class="o">=</span> <span class="n">img</span><span class="o">.</span><span class="n">dtype</span> <span class="k">if</span> <span class="n">torch</span><span class="o">.</span><span class="n">is_floating_point</span><span class="p">(</span><span class="n">img</span><span class="p">)</span> <span class="k">else</span> <span class="n">torch</span><span class="o">.</span><span class="n">float32</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">_get_gaussian_kernel2d</span><span class="p">(</span><span class="n">kernel_size</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">device</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">device</span><span class="p">)</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">img</span><span class="p">,</span> <span class="n">need_cast</span><span class="p">,</span> <span class="n">need_squeeze</span><span class="p">,</span> <span class="n">out_dtype</span> <span class="o">=</span> <span class="n">_cast_squeeze_in</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

    <span class="c1"># padding = (left, right, top, bottom)</span>
    <span class="n">padding</span> <span class="o">=</span> <span class="p">[</span><span class="n">kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">torch_pad</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">padding</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;reflect&quot;</span><span class="p">)</span>
    <span class="n">img</span> <span class="o">=</span> <span class="n">conv2d</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="n">groups</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">])</span>

    <span class="n">img</span> <span class="o">=</span> <span class="n">_cast_squeeze_out</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">need_cast</span><span class="p">,</span> <span class="n">need_squeeze</span><span class="p">,</span> <span class="n">out_dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Medical Imaging Technology Lab @ Sibionics.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>